{"version":3,"sources":["../src/bin.ts","../src/highlighter.ts"],"sourcesContent":["/**\r\n * Prismalux - Prisma Schema Highlighter\r\n * Developed by Artyom Gorlovetskiy (unbywyd)\r\n * Website: https://unbywyd.com\r\n * \r\n * This tool helps you to highlight and filter Prisma schema files directly from the command line.\r\n */\r\n\r\nimport fs from \"fs\";\r\nimport path from \"path\";\r\nimport highlighter from \"./highlighter.js\";\r\n\r\n// Function to load Prisma Schema\r\nexport const loadPrismaSchema = async (inputPath?: string): Promise<{ schema: string; path: string }> => {\r\n    const cwd = process.cwd();\r\n    let schemaPath: string | null = null;\r\n\r\n    // Check if a path is provided\r\n    if (inputPath) {\r\n        // Determine if the path is absolute or relative\r\n        const resolvedPath = path.isAbsolute(inputPath) ? inputPath : path.resolve(cwd, inputPath);\r\n\r\n        if (fs.existsSync(resolvedPath)) {\r\n            const stat = fs.statSync(resolvedPath);\r\n\r\n            if (stat.isDirectory()) {\r\n                // If it's a directory, look for `schema.prisma`\r\n                const possibleSchemaPaths = [\r\n                    path.join(resolvedPath, \"prisma\", \"schema.prisma\"),\r\n                    path.join(resolvedPath, \"schema.prisma\")\r\n                ];\r\n\r\n                schemaPath = possibleSchemaPaths.find(fs.existsSync) || null;\r\n            } else if (stat.isFile()) {\r\n                // If it's a file, use it directly\r\n                schemaPath = resolvedPath;\r\n            }\r\n        }\r\n\r\n        if (!schemaPath) {\r\n            throw new Error(`❌ Path \"${inputPath}\" does not point to a valid Prisma schema file or directory.`);\r\n        }\r\n    } else {\r\n        // If no path is provided, look in standard locations\r\n        const possibleSchemaPaths = [\r\n            path.join(cwd, \"prisma\", \"schema.prisma\"),\r\n            path.join(cwd, \"schema.prisma\")\r\n        ];\r\n        schemaPath = possibleSchemaPaths.find(fs.existsSync) || null;\r\n    }\r\n\r\n    // If no file is found, throw an error\r\n    if (!schemaPath) {\r\n        throw new Error(`❌ Prisma schema file not found. Try: prismalux --path=[path_to_schema]`);\r\n    }\r\n\r\n    // Read the file\r\n    const schemaContent = await fs.promises.readFile(schemaPath, \"utf-8\");\r\n\r\n    // Check if it's really a Prisma schema (look for keywords)\r\n    if (!/^\\s*(generator|datasource|client)\\b/m.test(schemaContent)) {\r\n        throw new Error(`❌ The file at \"${schemaPath}\" does not appear to be a valid Prisma schema.`);\r\n    }\r\n\r\n    return { schema: schemaContent, path: schemaPath };\r\n};\r\n\r\n\r\n// Function to parse CLI arguments\r\nconst parseArgs = (args: string[]) => {\r\n    const options: Record<string, string | boolean> = {};\r\n    args.forEach(arg => {\r\n        const match = arg.match(/^--(\\w+)(?:=(.+))?$/);\r\n        if (match) {\r\n            const [, key, value] = match;\r\n            options[key] = value !== undefined ? value : true;\r\n        }\r\n    });\r\n    return options;\r\n};\r\n\r\n// CLI: process.argv\r\nconst args = process.argv.slice(2);\r\nconst options = parseArgs(args);\r\n\r\n// Handling --help and --version flags\r\nif (options.help || options.h) {\r\n    console.log(`\r\nUsage: prismalux --path=[path_to_schema] [--filter=modelName]\r\n\r\nOptions:\r\n  --help, -h            Show this help message\r\n  --version, -v         Show the installed version\r\n  --path=[path]         Specify a Prisma schema file (default: ./prisma/schema.prisma)\r\n  --filter=[name], --f  Highlight only the specified model or enum\r\n  `);\r\n    process.exit(0);\r\n}\r\n\r\nif (options.version || options.v) {\r\n    console.log(\"Prismalux v0.1.0\");\r\n    process.exit(0);\r\n}\r\n\r\n// Filtering model/enum\r\nconst filterSchemaPart = (schema: string, filterInput: string): string | null => {\r\n    const filterNames = filterInput.split(/[,| ]+/).map(name => name.trim()).filter(name => name.length > 0);\r\n\r\n    if (filterNames.length === 0) {\r\n        console.error(\"❌ No valid model or enum names provided.\");\r\n        return null;\r\n    }\r\n    let results: string[] = [];\r\n\r\n    for (const filterName of filterNames) {\r\n        const regex = new RegExp(`\\\\b(model|enum)\\\\s+${filterName}\\\\s*{[\\\\s\\\\S]*?}`, \"g\");\r\n        const match = schema.match(regex);\r\n        if (match) {\r\n            results.push(...match);\r\n        }\r\n    }\r\n    return results.length > 0 ? results.join(\"\\n\\n\") : null;\r\n};\r\n\r\n\r\n// Loading and rendering Prisma Schema\r\n(async () => {\r\n    try {\r\n        const filePath = typeof options.path === \"string\" ? options.path : undefined;\r\n        const { schema, path } = await loadPrismaSchema(filePath);\r\n\r\n        console.log(`\\n✨ Highlighting Prisma schema: ${path}\\n`);\r\n\r\n        let schemaToHighlight = schema;\r\n        const filter = options?.filter || options?.f;\r\n        if (typeof filter === \"string\") {\r\n            const filteredSchema = filterSchemaPart(schema, filter);\r\n            if (!filteredSchema) {\r\n                console.error(`❌ No model or enum found for \"${filter}\".`);\r\n                process.exit(1);\r\n            }\r\n            schemaToHighlight = filteredSchema;\r\n        }\r\n\r\n        console.log(highlighter.highlight(schemaToHighlight));\r\n    } catch (error) {\r\n        console.error(error instanceof Error ? error.message : \"❌ An unknown error occurred.\");\r\n        process.exit(1);\r\n    }\r\n})();\r\n\r\n","export interface HighlightConfig {\r\n    enableColors?: boolean; // Flag to enable/disable colors\r\n    colors?: Record<string, string>; // Custom color scheme\r\n}\r\nexport class PrismaHighlighter {\r\n    private config: Required<HighlightConfig>;\r\n    private static DEFAULT_COLORS = {\r\n        reset: \"\\x1b[0m\", gray: \"\\x1b[90m\", whiteBold: \"\\x1b[1;37m\", cyanBold: \"\\x1b[1;36m\",\r\n        purple: \"\\x1b[38;5;201m\", lightPurple: \"\\x1b[38;5;177m\", purpleDark: \"\\x1b[38;5;93m\",\r\n        darkBlue: \"\\x1b[38;5;63m\", lightBlue: \"\\x1b[38;5;111m\", yellow: \"\\x1b[33m\",\r\n        yellowBold: \"\\x1b[1;33m\", yellowBright: \"\\x1b[93m\", orange: \"\\x1b[38;5;208m\",\r\n        green: \"\\x1b[32m\", greenBright: \"\\x1b[92m\", cyan: \"\\x1b[36m\", cyanLight: \"\\x1b[96m\", greenDark: \"\\x1b[38;5;22m\"\r\n    };\r\n    private static PRISMA_TYPES = new Set([\r\n        \"String\", \"Int\", \"Boolean\", \"DateTime\", \"Json\", \"Float\", \"Decimal\", \"BigInt\", \"Bytes\"\r\n    ]);\r\n    constructor(config: HighlightConfig = {}) {\r\n        this.config = {\r\n            enableColors: config.enableColors ?? true,\r\n            colors: { ...PrismaHighlighter.DEFAULT_COLORS, ...config.colors }\r\n        };\r\n    }\r\n    private colorize(text: string, color: keyof typeof PrismaHighlighter.DEFAULT_COLORS): string {\r\n        if (!this.config.enableColors) return text;\r\n        return `${this.config.colors[color] || \"\"}${text}${this.config.colors.reset}`;\r\n    }\r\n    public highlight(schema: string): string {\r\n        return schema.replace(/\\r\\n/g, \"\\n\").split(\"\\n\").map(_line => {\r\n            const line = _line.replace(/@\\w+(?=\\s|$)/g, match => this.colorize(match, \"greenBright\")\r\n            ).replace(/(@\\w+)(\\()([^()]*)(\\))/g, (_, annotation, openBracket, args, closeBracket) => {\r\n                const content = args.split(',').map((arg: string) => {\r\n                    if (/^\\s*\"([^\"]+)\"\\s*$/.test(arg)) return this.colorize(arg, \"purpleDark\");\r\n                    if (arg.includes(\":\")) {\r\n                        const [key, value] = arg.split(\":\").map(part => part.trim());\r\n                        const coloredValue = value.replace(/\\[(.*?)\\]/g, (_, inner) =>\r\n                            `${this.colorize(\"[\", \"yellowBright\")}${this.colorize(inner, \"orange\")}${this.colorize(\"]\", \"yellowBright\")}`\r\n                        );\r\n                        return `${this.colorize(key, \"yellowBright\")}: ${coloredValue}`;\r\n                    }\r\n                    return this.colorize(arg, \"cyan\");\r\n                }).join(\", \");\r\n                return this.colorize(annotation, \"yellow\") + this.colorize(openBracket, \"yellowBold\") + content + this.colorize(closeBracket, \"yellowBold\");\r\n            }).replace(/(@\\w+)(\\s*\\(\\s*)(.+)(\\s*\\))/g, (_, annotation, openBracket, value, closeBracket) => {\r\n                return this.colorize(annotation, \"yellow\") + this.colorize(openBracket, \"yellowBright\") + this.colorize(value, \"cyan\") + this.colorize(closeBracket, \"yellowBright\");\r\n            }).replace(/\\b(model|enum)\\s+([A-Z][a-zA-Z0-9_]*)/g, (_, keyword, modelName) =>\r\n                `${this.colorize(keyword, \"cyanBold\")} ${this.colorize(modelName, \"purple\")}`\r\n            ).replace(/\\/\\/(.*)$/gm, (_, comment) => this.colorize(\"// \" + comment, \"green\")\r\n            ).replace(/\\/\\*([\\s\\S]*?)\\*\\//g, (_, content) => this.colorize(`/*${content}*/`, \"greenDark\")\r\n            ).replace(/^(\\s*\\S+)(.*)$/, (match, firstPart, secondPart) => {\r\n                if (!secondPart.trim() && ![\"{\", \"}\"].includes(firstPart.trim())) return this.colorize(match, \"cyan\");\r\n                return firstPart + (secondPart || \"\").replace(\r\n                    /(?<![\"'])(?<=\\s|^)([A-Z][a-zA-Z0-9_]*)(\\?)?(\\[\\])?(?![^()]*\\))/g,\r\n                    (match, type, optional) => {\r\n                        const isOptional = optional !== undefined;\r\n                        if (PrismaHighlighter.PRISMA_TYPES.has(type)) {\r\n                            return isOptional ? this.colorize(match, \"gray\") : this.colorize(match, \"lightBlue\");\r\n                        } else {\r\n                            return isOptional ? this.colorize(match, \"lightPurple\") : this.colorize(match, \"purple\");\r\n                        }\r\n                    }\r\n                );\r\n            });\r\n            return line;\r\n        }).join(\"\\n\").replace(/\\b(generator|datasource)\\s+(\\w+)\\s*({)([\\s\\S]*?)(})/g, (match, blockType, name, openBrace, content, closeBrace) => {\r\n            const highlightedContent = content\r\n                .replace(/\\b(provider|output|url)\\b/g, key => this.colorize(key, \"yellowBright\"))\r\n                .replace(/\"([^\"]+)\"/g, (_, value) => `\"${this.colorize(value, \"gray\")}\"`);\r\n            return `${this.colorize(blockType, \"greenBright\")} ${this.colorize(name, \"purple\")} ${this.colorize(openBrace, \"gray\")}${highlightedContent}${this.colorize(closeBrace, \"gray\")}`;\r\n        });\r\n    }\r\n}\r\n\r\nconst highlighter = new PrismaHighlighter();\r\nexport default highlighter;\r\n"],"mappings":"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","names":["args","_","match","args","options","path"]}